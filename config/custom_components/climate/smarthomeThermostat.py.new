
import sys
sys.path.append('/amaroq/smarthome/pylib')
from amaroq_home import mysql

import logging
import asyncio

from homeassistant.components.climate import ( ClimateDevice,
    STATE_HEAT, STATE_COOL, STATE_FAN_ONLY, STATE_IDLE,
    SUPPORT_OPERATION_MODE, SUPPORT_TARGET_TEMPERATURE, SUPPORT_HOLD_MODE)
from homeassistant.const import ( STATE_ON, STATE_OFF, ATTR_TEMPERATURE )

_LOGGER = logging.getLogger(__name__)

SUPPORT_FLAGS = (SUPPORT_TARGET_TEMPERATURE | SUPPORT_HOLD_MODE | SUPPORT_FAN_MODE)

# Mysql
db = mysql.Mysql('hass')

@asyncio.coroutine
def async_setup_platform(hass, config, async_add_entities, discovery_info=None):
    """Setup the Awesome Light platform."""

    # Add devices
    async_add_entities([SmarthomeThermostat(hass, 'Thermostat')])

class SmarthomeThermostat(ClimateDevice):
    """Simplified interface to a denson.cc thermostat."""

    def __init__(self, hass, name):
        """Initialize a DCC_Thermostat."""

        self._name = name
        self._mode = STATE_HEAT
        self._state = STATE_OFF
        self._units = hass.config.units.temperature_unit

        self._target_temp = db.getVariable('House_Heat','setpoint')
        self._cur_temp = self.CtoF(db.getSensorCurrent('House','temp'))
        self._cur_fan = STATE_OFF

        _LOGGER.info("smarthomeThermostat initialized")

    @property
    def supported_features(self):
        """Return the list of supported features."""
        return SUPPORT_FLAGS
    
    @property
    def name(self):
        """Return the display name of this thermostat."""
        return self._name

    @property
    def state(self):
        """Return the current dynamic state."""
        return self._state
    
    @property
    def current_operation(self):
        """Return current set operation ie. heat, cool, fan, idle."""
        return self._mode

    @property
    def is_on(self):
        """Return true if on."""
        return self._state != STATE_OFF

    @property
    def current_fan_mode(self):
        """Return the fan setting."""
        return self._cur_fan

    @property
    def operation_list(self):
        return [STATE_HEAT, STATE_FAN_ONLY]

    @property
    def temperature_unit(self):
        """Return the unit of measurement."""
        return self._units

    @property
    def current_temperature(self):
        """Return the sensor temperature."""
        return int(round(self._cur_temp))

    @property
    def target_temperature(self):
        """Return the target temperature."""
        return int(round(self._target_temp))

    @asyncio.coroutine
    def async_update(self):
        self._target_temp = db.getVariable('House_Heat','setpoint')
        self._cur_temp = self.CtoF(db.getSensorCurrent('House','temp'))

        info = db.getDeviceInfo('House_Heat')

        if info is not None and info['status'] == 100:
            self._state = 'heat'
        else:
            self._state = 'idle'

    @asyncio.coroutine
    def async_set_temperature(self, **kwargs):
        """Set new target temperature."""

        temperature = kwargs.get(ATTR_TEMPERATURE)
        if temperature is None:
            return

        self._target_temp = temperature

        db.setVariable('House_Heat','setpoint',self._target_temp)

    @asyncio.coroutine
    def async_set_operation_mode(self, operation_mode):
        """Set operation mode."""
        self._mode = operation_mode

        if self._mode == 


        if operation_mode == STATE_OFF:
            self._mode = 'off'
        elif operation_mode == STATE_HEAT:
            self._mode = 'heat'
        elif operation_mode == STATE_COOL:
            self._mode = 'cool'
        elif operation_mode == STATE_FAN_ONLY:
            self._mode = 'fan'
        else:
            self._mode = 'off'

        #ws = yield from asyncws.connect(self._url)
        #rqst = Request('set_mode', mode=self._mode)
        #yield from ws.send(json.dumps(rqst))
        #result = yield from ws.recv()
        #ws.close()
        #_LOGGER.info('Set Mode Result: %s', str(result))
        return

    def CtoF(self, C):
        return (float(C)*1.8)+32.0

    def FtoC(self, F):
        return (float(F)-32.0)/1.8

